name: Sync and Merge Upstream Repositories
on:
  workflow_dispatch: # 手动触发
  schedule:
    - cron: '0 */3 * * *' # 每3小时自动触发一次

jobs:
  sync-and-merge:
    runs-on: ubuntu-latest
    env:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
      TARGET_REPO: t96mytell/openwrt-packages-23.05
      TARGET_BRANCH: main
    
    steps:
      # Step 0: Checkout Target Repository
      - name: Checkout Target Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.TARGET_REPO }}
          ref: ${{ env.TARGET_BRANCH }}
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0
      
      # 调试：打印检出信息
      - name: Print Checkout Information
        run: |
          echo "当前工作目录: $(pwd)"
          echo "仓库内容:"
          ls -la
      
      # 确保.git目录存在
      - name: Verify .git folder
        run: |
          if [ ! -d ".git" ]; then
            echo "错误: .git目录不存在!"
            exit 1
          else
            echo ".git目录验证通过"
          fi
      
      # 确保有初始提交
      - name: Ensure initial commit exists
        run: |
          if git rev-parse --verify HEAD >/dev/null 2>&1; then
            echo "仓库已有提交记录"
          else
            echo "创建初始提交..."
            touch README.md
            git add README.md
            git commit -m "Initial commit"
            git push origin ${{ env.TARGET_BRANCH }}
          fi

      - name: Make git-short-commit.sh executable
        run: chmod +x .github/scripts/git-short-commit.sh
      
      # Step 1: 支持无顶层目录仓库和通用嵌套目录的同步方案
      - name: Sync from upstream repositories
        run: |
          set -euo pipefail
          
          # 同步函数（支持按 branch 或 commit 同步）
          sync_repo() {
            local repo_url=$1
            local ref=$2 # 可以是分支名或commit hash
            local clone_dir=$3
            local mappings=$4
            
            # 检查映射关系是否为空 - 如果为空则跳过
            if [ -z "$mappings" ]; then
              echo "========================================"
              echo "跳过仓库: $repo_url (分支或commit : $ref)"
              echo "原因: 映射关系为空"
              echo "========================================"
              return 0
            fi
            
            echo "========================================"
            echo "处理仓库: $repo_url (分支或commit : $ref)"
            echo "临时目录: $clone_dir"
            echo "映射关系: $mappings"
            echo "----------------------------------------"
            
            # 克隆仓库
            echo "正在克隆仓库..."
            git clone --quiet "https://${{ secrets.PERSONAL_ACCESS_TOKEN }}@$repo_url" "$clone_dir" || {
              echo "错误: 克隆仓库失败 - $repo_url"
              return 1
            }

            echo "正在切换到指定的引用 (branch/commit): $ref..."
            (
              cd "$clone_dir" && git checkout --quiet "$ref"
            ) || {
              echo "错误: 切换到引用 '$ref' 失败"
              return 1
            }
            
            # 验证克隆结果
            if [ ! -d "$clone_dir" ] || [ -z "$(ls -A "$clone_dir")" ]; then
              echo "错误: 克隆目录为空 - $clone_dir"
              return 1
            fi
            
            # 解析映射关系
            IFS=',' read -ra mapping_list <<< "$mappings"
            for mapping in "${mapping_list[@]}"; do
              # 去除映射字符串中的空格
              mapping=$(echo "$mapping" | tr -d '[:space:]')
              
              # 分割源路径和目标路径
              IFS=':' read -r src_path dest_path <<< "$mapping"
              
              # 验证目标路径 - 禁止使用根目录(.)
              if [ -z "$dest_path" ] || [ "$dest_path" == "." ]; then
                echo "错误: 目标路径不能为空或根目录(.) - 请指定具体路径"
                return 1
              fi
              
              # 特殊处理：空源路径表示整个仓库根目录
              if [ -z "$src_path" ]; then
                src_path="."
                echo "检测到空源路径 - 将同步整个仓库根目录"
              fi
              
              # 处理路径格式
              src_path="${src_path%/}"
              dest_path="${dest_path%/}"
              
              # 完整源路径
              full_src="$clone_dir/$src_path"
              
              echo "同步: $src_path → $dest_path"
              
              if [ -e "$full_src" ]; then
                # 创建目标目录的父目录
                mkdir -p "$(dirname "./$dest_path")"
                
                # 执行同步（根据源类型使用不同参数）
                if [ "$src_path" == "." ]; then
                  # 同步整个仓库根目录（排除.git等目录）
                  echo "正在同步整个仓库根目录..."
                  rsync -av --delete-after \
                    --exclude='/.git' \
                    --exclude='/.github' \
                    --exclude='/LICENSE' \
                    --exclude='/README.md' \
                    "$clone_dir/" \
                    "./$dest_path/"
                elif [ -d "$full_src" ]; then
                  # 同步目录
                  echo "正在同步目录内容..."
                  rsync -av --delete-after \
                    "$full_src/" \
                    "./$dest_path/"
                else
                  # 同步单个文件
                  echo "正在同步文件..."
                  rsync -av \
                    "$full_src" \
                    "./$dest_path"
                fi
                
                # 验证同步结果
                if [ -d "$full_src" ] && [ ! -d "./$dest_path" ]; then
                  echo "错误: 目标目录未创建 - ./$dest_path"
                  return 1
                elif [ -f "$full_src" ] && [ ! -f "./$dest_path" ]; then
                  echo "错误: 目标文件未创建 - ./$dest_path"
                  return 1
                fi
                
                echo "同步成功! 目标内容:"
                ls -lA "./$dest_path"
              else
                echo "警告: 源路径不存在 - $full_src"
                echo "目录结构:"
                find "$clone_dir" -maxdepth 3 -type d | sort
                return 1
              fi
            done
            
            # 清理
            echo "清理临时目录..."
            rm -rf "$clone_dir"
            echo "----------------------------------------"
            echo "仓库处理完成: $repo_url"
            echo "========================================"
          }
          
          # 同步Siriling/5G-Modem-Support
          sync_repo "github.com/Siriling/5G-Modem-Support.git" "main" "5G-Modem-Support" \
            "fibocom-dial:fibocom-dial,\
            fibocom_MHI:fibocom_MHI,\
            fibocom_QMI_WWAN:fibocom_QMI_WWAN,\
            luci-app-cpe:luci-app-cpe,\
            luci-app-gobinetmodem:luci-app-gobinetmodem,\
            luci-app-hypermodem:luci-app-hypermodem,\
            luci-app-modem:luci-app-modem,\
            luci-app-pcimodem:luci-app-pcimodem,\
            luci-app-sms-tool:luci-app-sms-tool,\
            luci-app-spdmodem:luci-app-spdmodem,\
            luci-app-usbmodem:luci-app-usbmodem,\
            meig-cm:meig-cm,\
            meig_QMI_WWAN:meig_QMI_WWAN,\
            ndisc:ndisc,\
            quectel_Gobinet:quectel_Gobinet,\
            quectel_MHI:quectel_MHI,\
            quectel_QMI_WWAN:quectel_QMI_WWAN,\
            quectel_SRPD_PCIE:quectel_SRPD_PCIE,\
            quectel_cm_5G:quectel_cm_5G,\
            sendat:sendat,\
            sms-tool:sms-tool"

          # 同步openwrt/packages
          sync_repo "github.com/openwrt/packages.git" "master" "openwrt-packages" \
            "net/keepalived:keepalived,\
            utils/runc:runc,\
            utils/tini:tini,\
            utils/docker:docker,\
            utils/dockerd:dockerd,\
            utils/containerd:containerd"

          # 同步openwrt/luci
          sync_repo "github.com/openwrt/luci.git" "master" "openwrt-luci" \
            ""

          # 同步lede主仓库包
          sync_repo "github.com/coolsnowwolf/lede.git" "master" "lede" \
            ""

          # 同步lede/packages
          sync_repo "github.com/coolsnowwolf/packages.git" "master" "lede-packages" \
            "net/uugamebooster:uugamebooster,\
            net/nft-qos:nft-qos"

          # 同步lede/luci
          sync_repo "github.com/coolsnowwolf/luci.git" "master" "lede-luci" \
            "applications/luci-app-uugamebooster:luci-app-uugamebooster"

          # 同步immortalwr主仓库包
          sync_repo "github.com/immortalwrt/immortalwrt.git" "master" "immortalwrt" \
            "package/network/utils/fullconenat:fullconenat,\
            package/network/utils/fullconenat-nft:fullconenat-nft"

          # 同步immortalwrt/packages
          sync_repo "github.com/immortalwrt/packages.git" "master" "immortalwrt-packages" \
            "lang/lua-neturl:lua-neturl"

          # 同步immortalwrt/luci
          sync_repo "github.com/immortalwrt/luci.git" "master" "immortalwrt-luci" \
            "applications/luci-app-keepalived:luci-app-keepalived,\
            applications/luci-app-dockerman:luci-app-dockerman"

          # 同步immortalwrt/luci > luci-app-nft-qos (按Commit)
          sync_repo "github.com/immortalwrt/luci.git" "27823f5" "immortalwrt-luci-app-nft-qos" \
            "applications/luci-app-nft-qos:luci-app-nft-qos"
          
          # 同步kenzok8/small-package
          sync_repo "github.com/kenzok8/small-package.git" "main" "small-package" \
            "luci-app-adguardhome:luci-app-adguardhome,\
            adguardhome:adguardhome,\
            cgroupfs-mount:cgroupfs-mount"

          # 同步kenzok8/small
          sync_repo "github.com/kenzok8/small.git" "master" "small" \
            "brook:brook,\
            chinadns-ng:chinadns-ng,\
            dns2socks:dns2socks,\
            dns2tcp:dns2tcp,\
            gn:gn,\
            hysteria:hysteria,\
            ipt2socks:ipt2socks,\
            luci-app-bypass:luci-app-bypass,\
            luci-app-fchomo:luci-app-fchomo,\
            luci-app-homeproxy:luci-app-homeproxy,\
            luci-app-mosdns:luci-app-mosdns,\
            luci-app-nikki:luci-app-nikki,\
            luci-app-openclash:luci-app-openclash,\
            luci-app-passwall:luci-app-passwall,\
            luci-app-passwall2:luci-app-passwall2,\
            luci-app-ssr-plus:luci-app-ssr-plus,\
            microsocks:microsocks,\
            mihomo:mihomo,\
            mosdns:mosdns,\
            naiveproxy:naiveproxy,\
            nikki:nikki,\
            pdnsd-alt:pdnsd-alt,\
            redsocks2:redsocks2,\
            shadow-tls:shadow-tls,\
            shadowsocks-rust:shadowsocks-rust,\
            shadowsocksr-libev:shadowsocksr-libev,\
            simple-obfs:simple-obfs,\
            sing-box:sing-box,\
            ssocks:ssocks,\
            tcping:tcping,\
            trojan-go:trojan-go,\
            tuic-client:tuic-client,\
            v2dat:v2dat,\
            v2ray-core:v2ray-core,\
            v2ray-geodata:v2ray-geodata,\
            v2ray-plugin:v2ray-plugin,\
            v2raya:v2raya,\
            xray-core:xray-core,\
            xray-plugin:xray-plugin,\
            geoview:geoview"

          # 同步fw876/helloworld
          sync_repo "github.com/fw876/helloworld.git" "master" "helloworld" \
            "shadowsocks-libev:shadowsocks-libev,\
            dns2socks-rust:dns2socks-rust,\
            trojan:trojan"

          # 同步xiaorouji/openwrt-passwall-packages
          sync_repo "github.com/xiaorouji/openwrt-passwall-packages.git" "main" "openwrt-passwall-packages" \
            "trojan-plus:trojan-plus"

          # 同步kiddin9/kwrt-packages
          sync_repo "github.com/kiddin9/kwrt-packages.git" "main" "kwrt-packages" \
            "luci-app-easymesh:luci-app-easymesh,\
            luci-app-leigod-acc:luci-app-leigod-acc,\
            leigod-acc:leigod-acc,\
            luci-app-pptp-server:luci-app-pptp-server,\
            luci-app-pppoe-relay:luci-app-pppoe-relay,\
            luci-app-pppoe-server:luci-app-pppoe-server,\
            luci-app-openvpn-server:luci-app-openvpn-server,\
            luci-app-openvpn-client:luci-app-openvpn-client,\
            luci-app-ipsec-server:luci-app-ipsec-server,\
            luci-app-ipsec-vpnd:luci-app-ipsec-vpnd,\
            luci-app-zerotier:luci-app-zerotier,\
            luci-app-einat:luci-app-einat,\
            openwrt-einat-ebpf:openwrt-einat-ebpf"
          
          # 最终验证
          echo "========================================"
          echo "所有仓库同步完成!"
          echo "最终目录结构:"
          find . -maxdepth 3 -type d | sort
          echo "========================================"

      # Step 2: 应用全局Makefile修复 - Luci引用
      - name: Apply Global Luci Makefile Fixes
        run: |
          echo "开始全局修复Makefile中的luci.mk引用路径..."
          modified_count=0
          skipped_count=0

          # 临时禁用错误退出
          set +e

          while IFS= read -r -d '' file; do
            [ -f "$file" ] || continue
            if grep -q 'include \(\.\./\)\+luci\.mk' "$file"; then
              echo "修复 $file 中的 luci.mk 引用..."
              sed -i 's|include \(\.\./\)\+luci\.mk|include $(TOPDIR)/feeds/luci/luci.mkk|g' "$file"
              if grep -q 'include $(TOPDIR)/feeds/luci/luci.mkk' "$file"; then
                ((modified_count++))
                echo "  → 修改成功"
              else
                echo "  → 警告: 修改后未找到新字符串"
              fi
            else
              ((skipped_count++))
            fi
          done < <(find . -type f -name "Makefile" -print0)

          # 恢复错误退出
          set -e

          echo "----------------------------------------"
          echo "共检查了 $((modified_count + skipped_count)) 个Makefile文件"
          echo "修改了 $modified_count 个文件"
          echo "跳过了 $skipped_count 个文件"
          echo "========================================"


      # Step 3: 应用全局Makefile修复 - Golang引用
      - name: Apply Global Golang Makefile Fixes
        run: |
          echo "开始全局修复Makefile中的golang-package.mk引用路径..."
          modified_count=0
          skipped_count=0

          # 临时禁用错误退出
          set +e

          while IFS= read -r -d '' file; do
            [ -f "$file" ] || continue
            if grep -q 'include \(\.\./\)\+lang/golang/golang-package\.mk' "$file"; then
              echo "修复 $file 中的 golang-package.mk 引用..."
              sed -i 's|include \(\.\./\)\+lang/golang/golang-package\.mk|include $(TOPDIR)/feeds/packages/lang/golang/golang-package.mk|g' "$file"
              if grep -q 'include $(TOPDIR)/feeds/packages/lang/golang/golang-package.mk' "$file"; then
                ((modified_count++))
                echo "  → 修改成功"
              else
                echo "  → 警告: 修改后未找到新字符串"
              fi
            else
              ((skipped_count++))
            fi
          done < <(find . -type f -name "Makefile" -print0)

          # 恢复错误退出
          set -e

          echo "----------------------------------------"
          echo "共检查了 $((modified_count + skipped_count)) 个Makefile文件"
          echo "修改了 $modified_count 个文件"
          echo "跳过了 $skipped_count 个文件"
          echo "========================================"


      # Step 4: 自定义 containerd 包
      - name: Customizing containerd package
        run: |
          # 初始化报告变量
          REPORT=""
          MAKEFILE="containerd/Makefile"

          # 定义变量
          CONTAINERD_PKG_VERSION="1.7.28"
          CONTAINERD_PKG_RELEASE="1"
          
          PKG_GIT_URL="github.com/containerd/containerd"
          PKG_GIT_REF="v$CONTAINERD_PKG_VERSION"
          PKG_SOURCE_URL="https://codeload.$PKG_GIT_URL/tar.gz/$PKG_GIT_REF"

          # 下载源码 tarball
          TMP_DIR=$(mktemp -d)
          wget -O "$TMP_DIR/source.tar.gz" "$PKG_SOURCE_URL"

          # 计算 SHA256
          CONTAINERD_PKG_HASH=$(sha256sum "$TMP_DIR/source.tar.gz" | cut -d' ' -f1)

          # 获取短 commit
          git clone --depth 1 --branch "$PKG_GIT_REF" "https://$PKG_GIT_URL" "$TMP_DIR/git-src"
          CONTAINERD_PKG_GIT_SHORT_COMMIT=$(git -C "$TMP_DIR/git-src" rev-parse --short HEAD)

          # 清理临时目录
          rm -rf "$TMP_DIR"

          # 步骤 : 替换 PKG_VERSION 和 PKG_RELEASE
          echo "步骤 : 替换 PKG_VERSION 和 PKG_RELEASE"
          if grep -q "^PKG_VERSION:=" "$MAKEFILE"; then
            sed -i "s/^PKG_VERSION:=.*/PKG_VERSION:=${CONTAINERD_PKG_VERSION}/" "$MAKEFILE"
            sed -i "s/^PKG_RELEASE:=.*/PKG_RELEASE:=${CONTAINERD_PKG_RELEASE}/" "$MAKEFILE"
            REPORT+="已更新 PKG_VERSION 和 PKG_RELEASE\n"
          else
            REPORT+="跳过：未找到 PKG_VERSION 变量\n"
          fi

          # 步骤 : 替换 PKG_HASH
          echo "步骤 : 替换 PKG_HASH"
          if grep -q "^PKG_HASH:=" "$MAKEFILE"; then
            sed -i "s/^PKG_HASH:=.*/PKG_HASH:=${CONTAINERD_PKG_HASH}/" "$MAKEFILE"
            REPORT+="已更新 PKG_HASH\n"
          else
            REPORT+="跳过：未找到 PKG_HASH 变量\n"
          fi

          # 步骤 : 替换 PKG_GIT_SHORT_COMMIT
          echo "步骤 : 替换 PKG_GIT_SHORT_COMMIT"
          if grep -q "^PKG_GIT_SHORT_COMMIT:=" "$MAKEFILE"; then
            sed -i "s/^PKG_GIT_SHORT_COMMIT:=.*/PKG_GIT_SHORT_COMMIT:=${CONTAINERD_PKG_GIT_SHORT_COMMIT}/" "$MAKEFILE"
            REPORT+="已更新 PKG_GIT_SHORT_COMMIT\n"
          else
            REPORT+="跳过：未找到 PKG_GIT_SHORT_COMMIT 变量\n"
          fi

          # 最终报告
          echo -e "\n===== 合并操作报告 ====="
          echo -e "$REPORT"

      # Step 5: 自定义 runc 包
      - name: Customizing runc package
        run: |
          # 初始化报告变量
          REPORT=""
          MAKEFILE="runc/Makefile"

          # 定义变量
          RUNC_PKG_VERSION="1.3.3"
          RUNC_PKG_RELEASE="1"
          
          PKG_GIT_URL="github.com/opencontainers/runc"
          PKG_GIT_REF="v$RUNC_PKG_VERSION"
          PKG_SOURCE_URL="https://codeload.$PKG_GIT_URL/tar.gz/$PKG_GIT_REF"

          # 下载源码 tarball
          TMP_DIR=$(mktemp -d)
          wget -O "$TMP_DIR/source.tar.gz" "$PKG_SOURCE_URL"

          # 计算 SHA256
          RUNC_PKG_HASH=$(sha256sum "$TMP_DIR/source.tar.gz" | cut -d' ' -f1)

          # 获取短 commit
          git clone --depth 1 --branch "$PKG_GIT_REF" "https://$PKG_GIT_URL" "$TMP_DIR/git-src"
          RUNC_PKG_GIT_SHORT_COMMIT=$(git -C "$TMP_DIR/git-src" rev-parse --short HEAD)

          # 清理临时目录
          rm -rf "$TMP_DIR"

          # 步骤 : 替换 PKG_VERSION 和 PKG_RELEASE
          echo "步骤 : 替换 PKG_VERSION 和 PKG_RELEASE"
          if grep -q "^PKG_VERSION:=" "$MAKEFILE"; then
            sed -i "s/^PKG_VERSION:=.*/PKG_VERSION:=${RUNC_PKG_VERSION}/" "$MAKEFILE"
            sed -i "s/^PKG_RELEASE:=.*/PKG_RELEASE:=${RUNC_PKG_RELEASE}/" "$MAKEFILE"
            REPORT+="已更新 PKG_VERSION 和 PKG_RELEASE\n"
          else
            REPORT+="跳过：未找到 PKG_VERSION 变量\n"
          fi

          # 步骤 : 替换 PKG_HASH
          echo "步骤 : 替换 PKG_HASH"
          if grep -q "^PKG_HASH:=" "$MAKEFILE"; then
            sed -i "s/^PKG_HASH:=.*/PKG_HASH:=${RUNC_PKG_HASH}/" "$MAKEFILE"
            REPORT+="已更新 PKG_HASH\n"
          else
            REPORT+="跳过：未找到 PKG_HASH 变量\n"
          fi

          # 步骤 : 替换 PKG_GIT_SHORT_COMMIT
          echo "步骤 : 替换 PKG_GIT_SHORT_COMMIT"
          if grep -q "^PKG_GIT_SHORT_COMMIT:=" "$MAKEFILE"; then
            sed -i "s/^PKG_GIT_SHORT_COMMIT:=.*/PKG_GIT_SHORT_COMMIT:=${RUNC_PKG_GIT_SHORT_COMMIT}/" "$MAKEFILE"
            REPORT+="已更新 PKG_GIT_SHORT_COMMIT\n"
          else
            REPORT+="跳过：未找到 PKG_GIT_SHORT_COMMIT 变量\n"
          fi

          # 最终报告
          echo -e "\n===== 合并操作报告 ====="
          echo -e "$REPORT"

      # Step 6: 自定义 Docker 社区版守护进程依赖
      - name: Customizing Docker CE daemon dependencies
        run: |
          # 初始化报告变量
          REPORT=""
          MAKEFILE="dockerd/Makefile"

          # 定义变量
          DOCKER_PKG_VERSION="29.0.0"
          DOCKER_PKG_RELEASE="1"
          
          PKG_GIT_URL="github.com/moby/moby"
          DOCKER_TAG_PREFIX="docker-v"
          PKG_GIT_REF="\$(DOCKER_TAG_PREFIX)\$(PKG_VERSION)"
          PKG_SOURCE_URL="https://codeload.$PKG_GIT_URL/tar.gz/${DOCKER_TAG_PREFIX}${DOCKER_PKG_VERSION}"

          # 下载源码 tarball
          TMP_DIR=$(mktemp -d)
          wget -O "$TMP_DIR/source.tar.gz" "$PKG_SOURCE_URL"

          # 计算 SHA256
          DOCKER_PKG_HASH=$(sha256sum "$TMP_DIR/source.tar.gz" | cut -d' ' -f1)
          
          # 获取短 commit
          git clone --depth 1 --branch "${DOCKER_TAG_PREFIX}${DOCKER_PKG_VERSION}" "https://$PKG_GIT_URL" "$TMP_DIR/git-src"
          DOCKER_PKG_GIT_SHORT_COMMIT=$(git -C "$TMP_DIR/git-src" rev-parse --short HEAD)
          
          # 清理临时目录
          rm -rf "$TMP_DIR"

          # 步骤 : 替换 PKG_VERSION 和 PKG_RELEASE
          echo "步骤 : 替换 PKG_VERSION 和 PKG_RELEASE"
          if grep -q "^PKG_VERSION:=" "$MAKEFILE"; then
            sed -i "s/^PKG_VERSION:=.*/PKG_VERSION:=${DOCKER_PKG_VERSION}/" "$MAKEFILE"
            sed -i "s/^PKG_RELEASE:=.*/PKG_RELEASE:=${DOCKER_PKG_RELEASE}/" "$MAKEFILE"
            REPORT+="已更新 PKG_VERSION 和 PKG_RELEASE\n"
          else
            REPORT+="跳过：未找到 PKG_VERSION 变量\n"
          fi

          # 步骤 : 替换 PKG_GIT_REF（保持内部变量引用，不硬编码）
          echo "步骤 : 替换 PKG_GIT_REF"
          if grep -q "^PKG_GIT_REF:=" "$MAKEFILE"; then
            sed -i "s|^PKG_GIT_REF:=.*|PKG_GIT_REF:=${PKG_GIT_REF}|" "$MAKEFILE"
            REPORT+="已更新 PKG_GIT_REF 为内部变量组合形式\n"
          else
            REPORT+="跳过：未找到 PKG_GIT_REF 变量\n"
          fi

          # 步骤 : 替换 PKG_HASH
          echo "步骤 : 替换 PKG_HASH"
          if grep -q "^PKG_HASH:=" "$MAKEFILE"; then
            sed -i "s/^PKG_HASH:=.*/PKG_HASH:=${DOCKER_PKG_HASH}/" "$MAKEFILE"
            REPORT+="已更新 PKG_HASH\n"
          else
            REPORT+="跳过：未找到 PKG_HASH 变量\n"
          fi

          # 步骤 : 替换 PKG_GIT_SHORT_COMMIT
          echo "步骤 : 替换 PKG_GIT_SHORT_COMMIT"
          if grep -q "^PKG_GIT_SHORT_COMMIT:=" "$MAKEFILE"; then
            sed -i "s/^PKG_GIT_SHORT_COMMIT:=.*/PKG_GIT_SHORT_COMMIT:=${DOCKER_PKG_GIT_SHORT_COMMIT}/" "$MAKEFILE"
            REPORT+="已更新 PKG_GIT_SHORT_COMMIT\n"
          else
            REPORT+="跳过：未找到 PKG_GIT_SHORT_COMMIT 变量\n"
          fi

          # 步骤 : 替换 ca-bundle 为 ca-certificates
          echo "步骤 : 替换 ca-bundle 为 ca-certificates"
          if grep -q '\+ca-bundle' "$MAKEFILE"; then
            sed -i 's/\+ca-bundle/\+ca-certificates/' "$MAKEFILE" || true
            if grep -q '\+ca-certificates' "$MAKEFILE"; then
              REPORT+="已将 ca-bundle 替换为 ca-certificates\n"
            else
              REPORT+="替换 ca-bundle 失败：未找到 +ca-certificates\n"
              echo "当前 DEPENDS 内容:"
              grep -A 10 "DEPENDS:=" "$MAKEFILE" || true
            fi
          else
            REPORT+="跳过：未找到 +ca-bundle 依赖项\n"
          fi

          # 步骤 : 添加额外依赖项（在 @!(mips||mips64||mipsel) 前插入）
          echo "步骤 : 添加额外依赖项"
          if grep -q '@!(mips||mips64||mipsel)' "$MAKEFILE"; then
            tmpfile=$(mktemp)
            awk 'BEGIN { inserted=0 }
              /@!\(mips\|\|mips64\|\|mipsel\)/ && !inserted {
                # 在锚点前插入这些依赖行（每行末尾保留反斜杠）
                print "    +fuse-overlayfs \\"
                print "    +kmod-vxlan +kmod-macvlan +kmod-dummy +kmod-crypto-gcm +kmod-crypto-seqiv +kmod-crypto-ghash \\"
                print "    +kmod-ipsec +kmod-nf-nathelper +kmod-nf-nathelper-extra +btrfs-progs \\"
                inserted=1
              }
              { print }
            ' "$MAKEFILE" > "$tmpfile" && mv "$tmpfile" "$MAKEFILE"

            if grep -q '+fuse-overlayfs' "$MAKEFILE" && grep -q '+btrfs-progs' "$MAKEFILE"; then
              REPORT+="已添加额外依赖项 (fuse-overlayfs, btrfs-progs 等)\n"
            else
              REPORT+="添加额外依赖项失败：部分依赖项添加失败\n"
              echo "当前 DEPENDS 内容:"
              grep -A 15 "DEPENDS:=" "$MAKEFILE" || true
            fi
          else
            REPORT+="跳过：未找到依赖项锚点 @!(mips||mips64||mipsel)\n"
          fi

          # 步骤 : 修改依赖检查路径
          echo "步骤 : 修改依赖检查路径"
          PATH_CHANGED=0
          for DEP in containerd runc tini; do
            OLD_PATH="../$DEP"
            NEW_PATH="../../packages/utils/$DEP"
            if grep -q "$OLD_PATH" "$MAKEFILE"; then
              sed -i "s#${OLD_PATH}#${NEW_PATH}#g" "$MAKEFILE" || true
              PATH_CHANGED=$((PATH_CHANGED+1))
            else
              REPORT+="跳过：未找到 $OLD_PATH 路径\n"
            fi
          done

          if [ $PATH_CHANGED -gt 0 ]; then
            if grep -q "EnsureVendoredVersion.*../../packages/utils" "$MAKEFILE"; then
              REPORT+="已修改 ${PATH_CHANGED} 个依赖路径\n"
            else
              REPORT+="路径修改可能未生效\n"
              grep "EnsureVendoredVersion" "$MAKEFILE" || true
            fi
          else
            REPORT+="跳过：未找到需要修改的路径\n"
          fi

          # 步骤 : 添加 UCI 默认配置（在安装段中插入）
          echo "步骤 : 添加 UCI 默认配置"
          INSTALL_ANCHOR='$(INSTALL_BIN) $(PKG_BUILD_DIR)/bundles/binary-daemon/docker-proxy $(1)/usr/bin/'
          if [ -f "./files/dockerd.uci-defaults" ]; then
            if grep -q "$INSTALL_ANCHOR" "$MAKEFILE"; then
              tmpfile=$(mktemp)
              awk -v anchor="$INSTALL_ANCHOR" 'BEGIN { added=0 }
                {
                  print
                  if (index($0, anchor) && !added) {
                    print "\t$(INSTALL_DIR) $(1)/etc/uci-defaults"
                    print "\t$(INSTALL_DATA) ./files/dockerd.uci-defaults $(1)/etc/uci-defaults/dockerd"
                    added=1
                  }
                }
              ' "$MAKEFILE" > "$tmpfile" && mv "$tmpfile" "$MAKEFILE"

              if grep -q 'etc/uci-defaults' "$MAKEFILE"; then
                REPORT+="已添加 UCI 默认配置\n"
              else
                REPORT+="添加 UCI 默认配置失败\n"
                sed -n '/define Package\/dockerd\/install/,/endef/p' "$MAKEFILE" || true
              fi
            else
              REPORT+="跳过：未找到安装锚点\n"
            fi
          else
            echo "警告: ./files/dockerd.uci-defaults 文件不存在，跳过步骤4的 UCI 配置添加"
            REPORT+="跳过：dockerd.uci-defaults 文件不存在\n"
          fi

          # 最终报告
          echo -e "\n===== 合并操作报告 ====="
          echo -e "$REPORT"

          # 检查 UCI 配置文件是否存在
          if [ ! -f "./files/dockerd.uci-defaults" ]; then
            echo "警告: ./files/dockerd.uci-defaults 文件不存在，UCI 配置可能无法正常工作"
          fi

      # Step 7: 自定义 Docker CLI 包
      - name: Customizing docker CLI package
        run: |
          # 初始化报告变量
          REPORT=""
          MAKEFILE="docker/Makefile"

          # 定义变量
          DOCKER_CLI_PKG_VERSION="29.0.0"
          DOCKER_CLI_PKG_RELEASE="2"
          
          PKG_GIT_URL="github.com/docker/cli"
          PKG_GIT_REF="v$DOCKER_CLI_PKG_VERSION"
          PKG_SOURCE_URL="https://codeload.$PKG_GIT_URL/tar.gz/$PKG_GIT_REF"
          
          # 下载源码 tarball
          TMP_DIR=$(mktemp -d)
          wget -O "$TMP_DIR/source.tar.gz" "$PKG_SOURCE_URL"
          
          # 计算 SHA256
          DOCKER_CLI_PKG_HASH=$(sha256sum "$TMP_DIR/source.tar.gz" | cut -d' ' -f1)
          
          # 获取短 commit
          git clone --depth 1 --branch "$PKG_GIT_REF" "https://$PKG_GIT_URL" "$TMP_DIR/git-src"
          DOCKER_CLI_PKG_GIT_SHORT_COMMIT=$(git -C "$TMP_DIR/git-src" rev-parse --short HEAD)
          
          # 清理临时目录
          rm -rf "$TMP_DIR"

          # 步骤 : 替换 PKG_VERSION 和 PKG_RELEASE
          echo "步骤 : 替换 PKG_VERSION 和 PKG_RELEASE"
          if grep -q "^PKG_VERSION:=" "$MAKEFILE"; then
            sed -i "s/^PKG_VERSION:=.*/PKG_VERSION:=${DOCKER_CLI_PKG_VERSION}/" "$MAKEFILE"
            sed -i "s/^PKG_RELEASE:=.*/PKG_RELEASE:=${DOCKER_CLI_PKG_RELEASE}/" "$MAKEFILE"
            REPORT+="已更新 PKG_VERSION 和 PKG_RELEASE\n"
          else
            REPORT+="跳过：未找到 PKG_VERSION 变量\n"
          fi

          # 步骤 : 替换 PKG_HASH
          echo "步骤 : 替换 PKG_HASH"
          if grep -q "^PKG_HASH:=" "$MAKEFILE"; then
            sed -i "s/^PKG_HASH:=.*/PKG_HASH:=${DOCKER_CLI_PKG_HASH}/" "$MAKEFILE"
            REPORT+="已更新 PKG_HASH\n"
          else
            REPORT+="跳过：未找到 PKG_HASH 变量\n"
          fi

          # 步骤 : 替换 PKG_GIT_SHORT_COMMIT
          echo "步骤 : 替换 PKG_GIT_SHORT_COMMIT"
          if grep -q "^PKG_GIT_SHORT_COMMIT:=" "$MAKEFILE"; then
            sed -i "s/^PKG_GIT_SHORT_COMMIT:=.*/PKG_GIT_SHORT_COMMIT:=${DOCKER_CLI_PKG_GIT_SHORT_COMMIT}/" "$MAKEFILE"
            REPORT+="已更新 PKG_GIT_SHORT_COMMIT\n"
          else
            REPORT+="跳过：未找到 PKG_GIT_SHORT_COMMIT 变量\n"
          fi

          # 最终报告
          echo -e "\n===== 合并操作报告 ====="
          echo -e "$REPORT"

      
      # Step 8: 配置Git凭据
      - name: Configure Git Credentials
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin \
            "https://${{ secrets.PERSONAL_ACCESS_TOKEN }}@github.com/${{ env.TARGET_REPO }}.git"
      
      # Step 9: 提交和推送更改
      - name: Commit and Push Changes
        run: |
          set -e
          
          # 切换到目标分支
          git checkout ${{ env.TARGET_BRANCH }} || \
            git checkout -b ${{ env.TARGET_BRANCH }}
          
          # 添加所有更改
          git add .
          
          # 检查是否有更改
          if git diff-index --quiet HEAD; then
            echo "没有需要提交的更改"
          else
            # 提交更改
            git commit -m "自动同步: 从上游仓库更新 $(date +'%Y-%m-%d %H:%M:%S')"
            
            # 拉取最新更改（尝试变基）
            echo "拉取最新更改..."
            git pull --rebase origin ${{ env.TARGET_BRANCH }} || true
            
            # 解决可能的冲突（保留远程版本）
            resolve_conflicts() {
              local files_to_resolve=("README.md" "LICENSE")
              for file in "${files_to_resolve[@]}"; do
                if git ls-files --unmerged | grep -q "$file"; then
                  echo "检测到冲突: $file, 保留远程版本..."
                  git checkout --theirs "$file"
                  git add "$file"
                fi
              done
            }
            
            # 检查是否有未解决的冲突
            if git ls-files --unmerged | grep -q .; then
              echo "检测到冲突，尝试解决..."
              resolve_conflicts
              git rebase --continue
            fi
            
            # 推送更改
            echo "推送更改到远程仓库..."
            git push origin ${{ env.TARGET_BRANCH }}
            echo "更改已成功推送!"
          fi
      # Step 10: 清理7天前的工作流运行记录
      - name: Cleanup old workflow runs
        uses: Mattraks/delete-workflow-runs@main
        with:
          retain_days: 7
          keep_minimum_runs: 5
          repository: ${{ github.repository }}
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
